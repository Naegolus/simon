/*
  This file is part of the DSP-Crowd project
  https://www.dsp-crowd.com

  Author(s):
      - Johannes Natter, office@dsp-crowd.com

  File created on 18.08.2025

  Copyright (C) 2025, Johannes Natter

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef APP_HAS_TCLAP
#define APP_HAS_TCLAP 0
#endif

#if defined(__unix__)
#include <signal.h>
#endif
#if defined(_WIN32)
#include <winsock2.h>
#include <windows.h>
#endif
#include <iostream>
#include <chrono>
#include <thread>
#if APP_HAS_TCLAP
#include <tclap/CmdLine.h>
#endif

#if APP_HAS_TCLAP
#include "TclapOutput.h"
#endif
#include "SimonSupervising.h"
#include "LibDspc.h"

#include "env.h"

using namespace std;
using namespace chrono;
#if APP_HAS_TCLAP
using namespace TCLAP;
#endif

Environment env;
SimonSupervising *pApp = NULL;

#if APP_HAS_TCLAP
class AppHelpOutput : public TclapOutput {};
#endif

/*
Literature
- http://man7.org/linux/man-pages/man7/signal.7.html
  - for enums: kill -l
  - sys/signal.h
  SIGHUP  1     hangup
  SIGINT  2     interrupt
  SIGQUIT 3     quit
  SIGILL  4     illegal instruction (not reset when caught)
  SIGTRAP 5     trace trap (not reset when caught)
  SIGABRT 6     abort()
  SIGPOLL 7     pollable event ([XSR] generated, not supported)
  SIGFPE  8     floating point exception
  SIGKILL 9     kill (cannot be caught or ignored)
- https://www.usna.edu/Users/cs/aviv/classes/ic221/s16/lec/19/lec.html
- http://www.alexonlinux.com/signal-handling-in-linux
*/
void applicationCloseRequest(int signum)
{
	(void)signum;
	cout << endl;
	pApp->unusedSet();
}

#if defined(_WIN32)
/*
Literature
- https://learn.microsoft.com/en-us/windows/console/setconsolectrlhandler
*/
BOOL WINAPI signalWinReceived(DWORD signal)
{
	if (signal != CTRL_C_EVENT)
		return FALSE;

	applicationCloseRequest(0);

	return TRUE;
}
#endif

#if !APP_HAS_TCLAP
void helpPrint()
{
	cout << endl << dPackageName << endl;
	cout << "Version: " << dVersion << endl;

	cout << endl;
	cout << "Usage: " << dAppName << " [code] [device]" << endl;
	cout << endl;
}
#endif

int main(int argc, char *argv[])
{
	env.haveTclap = 1;
	env.verbosity = 0;
#if defined(__unix__)
	env.coreDump = false;
#endif

#if APP_HAS_TCLAP
	int res;

	CmdLine cmd("Command description message", ' ', appVersion());

	AppHelpOutput aho;
#if 1
	aho.package = dPackageName;
	aho.versionApp = dVersion;
	aho.nameApp = dAppName;
	aho.copyright = " Â© 2025 DSP-Crowd Electronics GmbH";
#endif
	cmd.setOutput(&aho);

	ValueArg<int> argVerbosity("v", "verbosity", "Verbosity: high => more output", false, 0, "uint8");
	cmd.add(argVerbosity);
#if defined(__unix__)
	SwitchArg argCoreDump("", "core-dump", "Enable core dumps", false);
	cmd.add(argCoreDump);
#endif
	SwitchArg argCtrlManual("", "ctrl-manual", "Use manual control (automatic control disabled)", false);
	cmd.add(argCtrlManual);

	cmd.parse(argc, argv);

	res = argVerbosity.getValue();
	if (res > 0 && res < 6)
		env.verbosity = res;

	levelLogSet(env.verbosity);
#if defined(__unix__)
	env.coreDump = argCoreDump.getValue();
#endif
#else
	env.haveTclap = 0;
	env.verbosity = 2;

	string argv1;

	if (argc >= 2)
		argv1 = string(argv[1]);

	if (argv1 == "--help" ||
			argv1 == "-h")
	{
		helpPrint();
		return 0;
	}
#endif

#if defined(_WIN32)
	// https://learn.microsoft.com/en-us/windows/console/setconsolectrlhandler
	BOOL okWin;

	okWin = SetConsoleCtrlHandler(signalWinReceived, TRUE);
	if (!okWin)
	{
		errLog(-1, "could not set ctrl handler");
		return 1;
	}
#else
	// https://www.gnu.org/software/libc/manual/html_node/Termination-Signals.html
	signal(SIGINT, applicationCloseRequest);
	signal(SIGTERM, applicationCloseRequest);
#endif
	pApp = SimonSupervising::create();
	if (!pApp)
	{
		errLog(-1, "could not create process");
		return 1;
	}

	pApp->procTreeDisplaySet(true);

	while (1)
	{
		for (int i = 0; i < 2; ++i)
			pApp->treeTick();

		this_thread::sleep_for(chrono::milliseconds(5));

		if (pApp->progress())
			continue;

		break;
	}

	Success success = pApp->success();
	Processing::destroy(pApp);

	Processing::applicationClose();

	filesStdClose();

	return !(success == Positive);
}

